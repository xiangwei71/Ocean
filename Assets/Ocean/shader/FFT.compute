// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Bit_Reverse_Buffer
{
    uint index;
};

RWStructuredBuffer<Bit_Reverse_Buffer> bit_reverse;


Texture2D<float4> input_texture;
RWTexture2D<float2> buffer_src;
RWTexture2D<float2> buffer_des;

void swap_buffer(inout RWTexture2D<float2> src, inout RWTexture2D<float2> des){
    RWTexture2D<float2> temp=src;
    src=des;
    des=temp;
}


void FFT(RWTexture2D<float2> buffer1, RWTexture2D<float2> buffer2, uint h) {
    /*二維DFT可以分解成 2次一維DFT
    B=MX
    Y=M(B)T
    */

    // [buffer1, buffer2] = butterfly(buffer1, buffer2, h, false);
    // [buffer1, buffer2] = transpose(buffer1, buffer2, h);
    // [buffer1, buffer2] = butterfly(buffer1, buffer2, h, false);

    // return [buffer1, buffer2];
}

// 蝴蝶算法的第1步
void set_element_order_per_column(RWTexture2D<float2> src, RWTexture2D<float2> des,in uint2 id) {
    des[id.xy]=src[uint2(id.x,bit_reverse[id.y].index)];
    // des[id.xy]=src[uint2(id.x,id.y)];
    swap_buffer(src,des);
}

void transpose(inout RWTexture2D<float2> src, inout RWTexture2D<float2> des,uint h,in uint2 id){
    uint2 index=uint2(h-id.y,h-id.x);
    des[id.xy] = float2(src[index].r,0);

    swap_buffer(buffer_src,buffer_des);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // fill buffer_src
    buffer_src[id.xy]=float2(input_texture[id.xy].r,0);

    uint h=512;
    set_element_order_per_column(buffer_src, buffer_des,id.xy);
}
